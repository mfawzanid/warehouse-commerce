// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.16.3 DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

// CreateProductRequest defines model for CreateProductRequest.
type CreateProductRequest struct {
	Enabled     bool   `json:"enabled"`
	Name        string `json:"name"`
	Price       int    `json:"price"`
	TotalStock  int    `json:"totalStock"`
	WarehouseId string `json:"warehouseId"`
}

// CreateProductResponse defines model for CreateProductResponse.
type CreateProductResponse struct {
	Id string `json:"id"`
}

// CreateShopRequest defines model for CreateShopRequest.
type CreateShopRequest struct {
	Name string `json:"name"`
}

// CreateShopResponse defines model for CreateShopResponse.
type CreateShopResponse struct {
	Id string `json:"id"`
}

// CreateWarehouseRequest defines model for CreateWarehouseRequest.
type CreateWarehouseRequest struct {
	Name string `json:"name"`
}

// CreateWarehouseResponse defines model for CreateWarehouseResponse.
type CreateWarehouseResponse struct {
	Id string `json:"id"`
}

// GetProductsByShopIdResponse defines model for GetProductsByShopIdResponse.
type GetProductsByShopIdResponse struct {
	Pagination Pagination `json:"pagination"`
	Products   []Product  `json:"products"`
}

// GetShopsResponse defines model for GetShopsResponse.
type GetShopsResponse struct {
	Pagination Pagination `json:"pagination"`
	Shops      []Shop     `json:"shops"`
}

// GetWarehousesResponse defines model for GetWarehousesResponse.
type GetWarehousesResponse struct {
	Pagination Pagination  `json:"pagination"`
	Warehouses []Warehouse `json:"warehouses"`
}

// LoginRequest defines model for LoginRequest.
type LoginRequest struct {
	Identifier     string `json:"identifier"`
	IdentifierType string `json:"identifierType"`
}

// LoginResponse defines model for LoginResponse.
type LoginResponse struct {
	Token string `json:"token"`
}

// OrderProductItem defines model for OrderProductItem.
type OrderProductItem struct {
	ProductId string `json:"productId"`
	Quantity  int    `json:"quantity"`
}

// OrderProductsRequest defines model for OrderProductsRequest.
type OrderProductsRequest struct {
	Items []OrderProductItem `json:"items"`
}

// OrderProductsResponse defines model for OrderProductsResponse.
type OrderProductsResponse struct {
	Id string `json:"id"`
}

// Pagination defines model for Pagination.
type Pagination struct {
	Page      int `json:"page"`
	PageSize  int `json:"pageSize"`
	Total     int `json:"total"`
	TotalPage int `json:"totalPage"`
}

// PayOrderRequest defines model for PayOrderRequest.
type PayOrderRequest struct {
	Amount int `json:"amount"`
}

// Product defines model for Product.
type Product struct {
	Enabled     bool   `json:"enabled"`
	Id          string `json:"id"`
	Name        string `json:"name"`
	Price       int    `json:"price"`
	TotalStock  int    `json:"totalStock"`
	WarehouseId string `json:"warehouseId"`
}

// RegisterUserRequest defines model for RegisterUserRequest.
type RegisterUserRequest struct {
	Identifier     string `json:"identifier"`
	IdentifierType string `json:"identifierType"`
}

// RegisterUserResponse defines model for RegisterUserResponse.
type RegisterUserResponse struct {
	Token string `json:"token"`
}

// Shop defines model for Shop.
type Shop struct {
	Id   string `json:"id"`
	Name string `json:"name"`
}

// TransferProductRequest defines model for TransferProductRequest.
type TransferProductRequest struct {
	DestinationWarehouseId string `json:"destinationWarehouseId"`
	ProductId              string `json:"productId"`
	SourceWarehouseId      string `json:"sourceWarehouseId"`
	TotalStock             int    `json:"totalStock"`
}

// UpdateProductStockRequest defines model for UpdateProductStockRequest.
type UpdateProductStockRequest struct {
	TotalStock  int    `json:"totalStock"`
	WarehouseId string `json:"warehouseId"`
}

// UpdateWarehouseStatusRequest defines model for UpdateWarehouseStatusRequest.
type UpdateWarehouseStatusRequest struct {
	Enabled bool `json:"enabled"`
}

// UpsertShopToWarehousesRequest defines model for UpsertShopToWarehousesRequest.
type UpsertShopToWarehousesRequest struct {
	Enabled      bool     `json:"enabled"`
	ShopId       string   `json:"shopId"`
	WarehouseIds []string `json:"warehouseIds"`
}

// Warehouse defines model for Warehouse.
type Warehouse struct {
	Enabled bool   `json:"enabled"`
	Id      string `json:"id"`
	Name    string `json:"name"`
}

// GetShopsParams defines parameters for GetShops.
type GetShopsParams struct {
	Page     int `form:"page" json:"page"`
	PageSize int `form:"pageSize" json:"pageSize"`
}

// GetProductsByShopIdParams defines parameters for GetProductsByShopId.
type GetProductsByShopIdParams struct {
	Page     int `form:"page" json:"page"`
	PageSize int `form:"pageSize" json:"pageSize"`
}

// GetWarehousesParams defines parameters for GetWarehouses.
type GetWarehousesParams struct {
	Page     int `form:"page" json:"page"`
	PageSize int `form:"pageSize" json:"pageSize"`
}

// PayOrderJSONRequestBody defines body for PayOrder for application/json ContentType.
type PayOrderJSONRequestBody = PayOrderRequest

// TransferProductJSONRequestBody defines body for TransferProduct for application/json ContentType.
type TransferProductJSONRequestBody = TransferProductRequest

// UpdateProductStockJSONRequestBody defines body for UpdateProductStock for application/json ContentType.
type UpdateProductStockJSONRequestBody = UpdateProductStockRequest

// CreateProductJSONRequestBody defines body for CreateProduct for application/json ContentType.
type CreateProductJSONRequestBody = CreateProductRequest

// OrderProductsJSONRequestBody defines body for OrderProducts for application/json ContentType.
type OrderProductsJSONRequestBody = OrderProductsRequest

// CreateShopJSONRequestBody defines body for CreateShop for application/json ContentType.
type CreateShopJSONRequestBody = CreateShopRequest

// UpsertShopToWarehousesJSONRequestBody defines body for UpsertShopToWarehouses for application/json ContentType.
type UpsertShopToWarehousesJSONRequestBody = UpsertShopToWarehousesRequest

// CreateWarehouseJSONRequestBody defines body for CreateWarehouse for application/json ContentType.
type CreateWarehouseJSONRequestBody = CreateWarehouseRequest

// UpdateWarehouseStatusJSONRequestBody defines body for UpdateWarehouseStatus for application/json ContentType.
type UpdateWarehouseStatusJSONRequestBody = UpdateWarehouseStatusRequest

// LoginJSONRequestBody defines body for Login for application/json ContentType.
type LoginJSONRequestBody = LoginRequest

// RegisterUserJSONRequestBody defines body for RegisterUser for application/json ContentType.
type RegisterUserJSONRequestBody = RegisterUserRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Pay an order.
	// (POST /api/v1/order/{orderId}/pay)
	PayOrder(ctx echo.Context, orderId string) error
	// This endpoint transfers product from a warehouse to another.
	// (POST /api/v1/product/transfer)
	TransferProduct(ctx echo.Context) error
	// This endpoint updates product total stock for a warehouse
	// (PUT /api/v1/product/{productId}/stock)
	UpdateProductStock(ctx echo.Context, productId string) error
	// This endpoint creates product
	// (POST /api/v1/products)
	CreateProduct(ctx echo.Context) error
	// Order products from a shop.
	// (POST /api/v1/shop/{shopId}/order)
	OrderProducts(ctx echo.Context, shopId string) error
	// This endpoint gets shop list
	// (GET /api/v1/shops)
	GetShops(ctx echo.Context, params GetShopsParams) error
	// This endpoint creates a shop.
	// (POST /api/v1/shops)
	CreateShop(ctx echo.Context) error
	// Get products from a shop.
	// (GET /api/v1/shops/{shopId}/products)
	GetProductsByShopId(ctx echo.Context, shopId string, params GetProductsByShopIdParams) error
	// This endpoint sets or unsets shop to warehouses.
	// (POST /api/v1/upsert-shop-warehouses)
	UpsertShopToWarehouses(ctx echo.Context) error
	// This endpoint gets warehouse list.
	// (GET /api/v1/warehouses)
	GetWarehouses(ctx echo.Context, params GetWarehousesParams) error
	// This endpoint creates a warehouse
	// (POST /api/v1/warehouses)
	CreateWarehouse(ctx echo.Context) error
	// This endpoint updates warehouse status
	// (PUT /api/v1/warehouses/{warehouseId}/status)
	UpdateWarehouseStatus(ctx echo.Context, warehouseId string) error
	// Health check endpoint
	// (GET /health)
	GetHealth(ctx echo.Context) error
	// This endpoint logs in the user
	// (POST /user/login)
	Login(ctx echo.Context) error
	// This endpoint registers new user
	// (POST /user/register)
	RegisterUser(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// PayOrder converts echo context to params.
func (w *ServerInterfaceWrapper) PayOrder(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "orderId" -------------
	var orderId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "orderId", runtime.ParamLocationPath, ctx.Param("orderId"), &orderId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter orderId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PayOrder(ctx, orderId)
	return err
}

// TransferProduct converts echo context to params.
func (w *ServerInterfaceWrapper) TransferProduct(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TransferProduct(ctx)
	return err
}

// UpdateProductStock converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateProductStock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "productId" -------------
	var productId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "productId", runtime.ParamLocationPath, ctx.Param("productId"), &productId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter productId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateProductStock(ctx, productId)
	return err
}

// CreateProduct converts echo context to params.
func (w *ServerInterfaceWrapper) CreateProduct(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateProduct(ctx)
	return err
}

// OrderProducts converts echo context to params.
func (w *ServerInterfaceWrapper) OrderProducts(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "shopId" -------------
	var shopId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "shopId", runtime.ParamLocationPath, ctx.Param("shopId"), &shopId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter shopId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.OrderProducts(ctx, shopId)
	return err
}

// GetShops converts echo context to params.
func (w *ServerInterfaceWrapper) GetShops(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetShopsParams
	// ------------- Required query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, true, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Required query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, true, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetShops(ctx, params)
	return err
}

// CreateShop converts echo context to params.
func (w *ServerInterfaceWrapper) CreateShop(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateShop(ctx)
	return err
}

// GetProductsByShopId converts echo context to params.
func (w *ServerInterfaceWrapper) GetProductsByShopId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "shopId" -------------
	var shopId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "shopId", runtime.ParamLocationPath, ctx.Param("shopId"), &shopId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter shopId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProductsByShopIdParams
	// ------------- Required query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, true, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Required query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, true, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetProductsByShopId(ctx, shopId, params)
	return err
}

// UpsertShopToWarehouses converts echo context to params.
func (w *ServerInterfaceWrapper) UpsertShopToWarehouses(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpsertShopToWarehouses(ctx)
	return err
}

// GetWarehouses converts echo context to params.
func (w *ServerInterfaceWrapper) GetWarehouses(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetWarehousesParams
	// ------------- Required query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, true, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Required query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, true, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetWarehouses(ctx, params)
	return err
}

// CreateWarehouse converts echo context to params.
func (w *ServerInterfaceWrapper) CreateWarehouse(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateWarehouse(ctx)
	return err
}

// UpdateWarehouseStatus converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateWarehouseStatus(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "warehouseId" -------------
	var warehouseId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "warehouseId", runtime.ParamLocationPath, ctx.Param("warehouseId"), &warehouseId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter warehouseId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateWarehouseStatus(ctx, warehouseId)
	return err
}

// GetHealth converts echo context to params.
func (w *ServerInterfaceWrapper) GetHealth(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetHealth(ctx)
	return err
}

// Login converts echo context to params.
func (w *ServerInterfaceWrapper) Login(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Login(ctx)
	return err
}

// RegisterUser converts echo context to params.
func (w *ServerInterfaceWrapper) RegisterUser(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RegisterUser(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST(baseURL+"/api/v1/order/:orderId/pay", wrapper.PayOrder)
	router.POST(baseURL+"/api/v1/product/transfer", wrapper.TransferProduct)
	router.PUT(baseURL+"/api/v1/product/:productId/stock", wrapper.UpdateProductStock)
	router.POST(baseURL+"/api/v1/products", wrapper.CreateProduct)
	router.POST(baseURL+"/api/v1/shop/:shopId/order", wrapper.OrderProducts)
	router.GET(baseURL+"/api/v1/shops", wrapper.GetShops)
	router.POST(baseURL+"/api/v1/shops", wrapper.CreateShop)
	router.GET(baseURL+"/api/v1/shops/:shopId/products", wrapper.GetProductsByShopId)
	router.POST(baseURL+"/api/v1/upsert-shop-warehouses", wrapper.UpsertShopToWarehouses)
	router.GET(baseURL+"/api/v1/warehouses", wrapper.GetWarehouses)
	router.POST(baseURL+"/api/v1/warehouses", wrapper.CreateWarehouse)
	router.PUT(baseURL+"/api/v1/warehouses/:warehouseId/status", wrapper.UpdateWarehouseStatus)
	router.GET(baseURL+"/health", wrapper.GetHealth)
	router.POST(baseURL+"/user/login", wrapper.Login)
	router.POST(baseURL+"/user/register", wrapper.RegisterUser)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
